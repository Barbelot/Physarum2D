#define NUM_THREADS 32
#define PI 3.14159265359
#define TWOPI 6.28318530718

#pragma kernel InitParticles
#pragma kernel SpawnParticles
#pragma kernel MoveParticles
#pragma kernel UpdateTrail
#pragma kernel CleanParticleTexture
#pragma kernel WriteParticleTexture

#include "Random.cginc"

struct Particle
{
	float2 position; 	// between 0-1
	float angle;	// in radians
	float4 color;
	float age;
	float lifetime;
};

float2 _TrailDimension;
float _Decay;
float _WProj;
bool _StimuliActive;

float _SensorAngle;
float _RotationAngle;
float _SensorOffsetDistance;
float _StepSize;
float _Lifetime;

float _DeltaTime;
float _AbsoluteTime;

RWStructuredBuffer<Particle> _ParticleBuffer;
RWTexture2D<float4> _TrailBuffer;
RWTexture2D<float4> _Stimuli;
RWTexture2D<float4> _ParticleTexture;

float2 _EmitterPosition;
float _EmitterRadius;
float _EmitterSpawnRate;
int _EmitterCapacity;

/**********************
FUNCTIONS
**********************/

float directTo(float2 pos, float2 directedPos)
{
	float2 direction = directedPos - pos;
	return atan2(direction.y, direction.x);
}

//return 1 if v inside the circle, return 0 otherwise
float insideCircle(float2 v, float2 center, float radius)
{
	float2 position = v - center;
	return (step(radius, length(position)) + 1.0) % 2.0;
}

float randomSign(float v)
{
	float x = Random(v);
	return (step(0.5, x) * 2.0) - 1.0;
}

float2 RandomInsideCircle(uint seed, float2 center, float radius) {

	float randomAngle = Random(seed) * TWOPI;
	return float2(cos(randomAngle), sin(randomAngle)) * radius * Random(seed + 1) + center;
}

void InitParticle(uint3 id) {

	_ParticleBuffer[id.x].position = RandomInsideCircle(id.x, _EmitterPosition, _EmitterRadius);
	_ParticleBuffer[id.x].angle = Random(id.x + 2) * TWOPI;
	_ParticleBuffer[id.x].color = float4(1, 1, 1, 1);
	_ParticleBuffer[id.x].lifetime = _Lifetime;
	_ParticleBuffer[id.x].age = -1;
}

/**********************
KERNELS
**********************/

[numthreads(NUM_THREADS,1,1)]
void InitParticles(uint3 id: SV_DISPATCHTHREADID)
{
	InitParticle(id);
}

[numthreads(NUM_THREADS, 1, 1)]
void SpawnParticles(uint3 id: SV_DISPATCHTHREADID)
{
	//Spawn
	if (_ParticleBuffer[id.x].age < 0 && Random(id.x + _AbsoluteTime) < _EmitterSpawnRate * _DeltaTime / _EmitterCapacity) {
		InitParticle(id);
		_ParticleBuffer[id.x].age = Random(id.x + 2) * _ParticleBuffer[id.x].lifetime;
	}

	//Did not spawn, ignore
	if (_ParticleBuffer[id.x].age < 0)
		return;

	//Age
	_ParticleBuffer[id.x].age += _DeltaTime;

	//Die
	if (_ParticleBuffer[id.x].age > _ParticleBuffer[id.x].lifetime && _ParticleBuffer[id.x].lifetime > 0)
		_ParticleBuffer[id.x].age = -1;
}

[numthreads(NUM_THREADS,1,1)]
void MoveParticles (uint3 id: SV_DISPATCHTHREADID)
{
	if (_ParticleBuffer[id.x].age < 0)
		return;

	float angle = _ParticleBuffer[id.x].angle;
	float2 pos 	= _ParticleBuffer[id.x].position;

	float2 frontPos 		= pos + float2(cos(angle) * _SensorOffsetDistance, sin(angle) * _SensorOffsetDistance);
	float2 frontLeftPos 	= pos + float2(cos(angle + _SensorAngle) * _SensorOffsetDistance, sin(angle + _SensorAngle) * _SensorOffsetDistance);
	float2 frontRightPos 	= pos + float2(cos(angle - _SensorAngle) * _SensorOffsetDistance, sin(angle - _SensorAngle) * _SensorOffsetDistance);
	
	float F 	= _TrailBuffer[frontPos * _TrailDimension.xy].x;
	float FL 	= _TrailBuffer[frontLeftPos * _TrailDimension.xy].x;
	float FR 	= _TrailBuffer[frontRightPos * _TrailDimension.xy].x;

	//decide on the next best step
	if((F > FL) && (F > FR))
	{
		//angle -=  rotationAngle;
	}
	else if	((F < FL) && (F < FR))
	{	
		angle = angle + _RotationAngle * randomSign(id.x);

		//if (FL > FR) {
		//	angle += rotationAngle;
		//}
		//else {
		//	angle -= rotationAngle;
		//}
	}
	else if	(FL < FR)
	{
		angle -= _RotationAngle; 
	}
	else if	(FR < FL )
	{
		angle += _RotationAngle; 
	}

	float2 nextPos = pos + float2(cos(angle) *_StepSize, sin(angle) *_StepSize);

	//check if nextPos is within the boundries
	//float t1 = insideCircle(nextPos, float2(0.5, 0.5), 0.5);
	//angle = angle + rotationAngle * randomSign(id.x+1) * (t1-1);
	//nextPos = saturate(nextPos*t1 + pos*(1-t1));

	_ParticleBuffer[id.x].position = nextPos;
	
	//if the particle moved, leave a mark in the trail buffer
	if(distance(nextPos, pos) > 0.0001)
	{
		_TrailBuffer[nextPos * _TrailDimension.xy] += _ParticleBuffer[id.x].color;
	}
	
	_ParticleBuffer[id.x].angle = angle;
}

[numthreads(NUM_THREADS, NUM_THREADS,1)]
void UpdateTrail (uint3 id : SV_DISPATCHTHREADID)
{
	float4 value;
	if(_StimuliActive)
	{
		value = _TrailBuffer[id.xy] + (_Stimuli[id.xy] * _WProj);
	}
	else
	{
		value = _TrailBuffer[id.xy];
	}
	
	float3 d = float3(1, -1, 0.0);
	
	//mean filter
	value = value;
	value += _TrailBuffer[id.xy - d.xx]; // -1,-1
	value += _TrailBuffer[id.xy - d.zx]; // 0, -1
	value += _TrailBuffer[id.xy - d.yx]; // +1, -1
	value += _TrailBuffer[id.xy - d.xz]; // -1, 0
	value += _TrailBuffer[id.xy + d.xz]; // +1, 0
	value += _TrailBuffer[id.xy + d.yx]; // -1, +1
	value += _TrailBuffer[id.xy + d.zx]; // 0, +1
	value += _TrailBuffer[id.xy + d.xx]; // +1, +1
	
	value = (value / 9) * (1-_Decay);

	_TrailBuffer[id.xy] = float4(value.x, value.y, value.z, 1.0);
}

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void CleanParticleTexture(uint3 id : SV_DISPATCHTHREADID)
{
	_ParticleTexture[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(NUM_THREADS, 1, 1)]
void WriteParticleTexture(uint3 id : SV_DISPATCHTHREADID)
{
	_ParticleTexture[_ParticleBuffer[id.x].position * _TrailDimension.xy] = float4(1, 1, 1, 1) * _ParticleBuffer[id.x].age / _ParticleBuffer[id.x].lifetime;
}

