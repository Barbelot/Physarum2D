#define NUM_THREADS 32
#define PI 3.14159265359
#define TWOPI 6.28318530718

#pragma kernel InitParticles
#pragma kernel SpawnParticles
#pragma kernel MoveParticles
#pragma kernel UpdateTrail
#pragma kernel CleanParticleTexture
#pragma kernel WriteParticleTexture
#pragma kernel UpdateParticleMap

#include "Random.cginc"

struct Particle
{
	float2 position; 	// between 0-1
	float angle;	// in radians
	float4 color;
	float age;
	float lifetime;
	float stimuliIntensity;
};

float2 _TrailDimension;
float2 _TrailSize;
float _Decay;

bool _StimuliActive;
float2 _StimuliDimension;
float _StimuliIntensity;
bool _StimuliToColor;


float _SensorAngle;
float _RotationAngle;
float _SensorOffsetDistance;
float _StepSize;
float2 _LifetimeMinMax;

float _DeltaTime;
float _AbsoluteTime;

RWStructuredBuffer<Particle> _ParticleBuffer;
RWTexture2D<float4> _TrailBuffer;
RWTexture2D<float4> _Stimuli;
RWTexture2D<float4> _ParticleTexture;
RWTexture2D<float4> _ParticlePositionMap;

float2 _EmitterPosition;
float2 _EmitterPreviousPosition;
float _EmitterRadius;
float _EmitterSpawnRate;
int _EmitterCapacity;
float4 _EmitterMainColor;
float4 _EmitterSecondaryColor;
float _EmitterSecondaryColorProbability;

float2 _ParticlePositionMapSize;

float2 _Gravity;

float _DirectionAngle;
float _DirectionStrength;

/**********************
FUNCTIONS
**********************/

float directTo(float2 pos, float2 directedPos)
{
	float2 direction = directedPos - pos;
	return atan2(direction.y, direction.x);
}

//return 1 if v inside the circle, return 0 otherwise
float insideCircle(float2 v, float2 center, float radius)
{
	float2 position = v - center;
	return (step(radius, length(position)) + 1.0) % 2.0;
}

float randomSign(float v)
{
	float x = Random(v);
	return (step(0.5, x) * 2.0) - 1.0;
}

float2 RandomInsideCircle(uint seed, float2 center, float radius) {

	float randomAngle = Random(seed) * TWOPI;
	return float2(cos(randomAngle), sin(randomAngle)) * radius * Random(seed + 1) + center;
}

void InitParticle(uint3 id) {

	_ParticleBuffer[id.x].position = RandomInsideCircle(id.x + 45, lerp(_EmitterPreviousPosition, _EmitterPosition, Random(id.x + 912)), _EmitterRadius);
	_ParticleBuffer[id.x].angle = Random(id.x + 2) * TWOPI;
	_ParticleBuffer[id.x].color = Random(id.x + 288) < _EmitterSecondaryColorProbability ? _EmitterSecondaryColor : _EmitterMainColor;
	_ParticleBuffer[id.x].lifetime = Random(id.x + 781) * (_LifetimeMinMax.y - _LifetimeMinMax.x) + _LifetimeMinMax.x;
	_ParticleBuffer[id.x].age = -1;
	_ParticleBuffer[id.x].stimuliIntensity = 0;
}

float2 GetUVFromPosition(float2 pos) {
	return pos / _TrailSize + float2(0.5, 0.5);
}

float ReadStimuli(float2 pos) {

	float2 posUV = GetUVFromPosition(pos);

	//value.rgb += _Stimuli[id.xy].rgb * _WProj;
	return (0.299 * _Stimuli[posUV * _StimuliDimension.xy].x + 0.587 * _Stimuli[posUV * _StimuliDimension.xy].y + 0.114 * _Stimuli[posUV * _StimuliDimension.xy].z);
}

float ReadTrail(float2 pos) {

	float2 posUV = GetUVFromPosition(pos);
	float value = _TrailBuffer[posUV * _TrailDimension.xy].w;

	if (_StimuliActive) {
		//value.rgb += _Stimuli[id.xy].rgb * _WProj;
		value += (0.299 * _Stimuli[posUV * _StimuliDimension.xy].x + 0.587 * _Stimuli[posUV * _StimuliDimension.xy].y + 0.114 * _Stimuli[posUV * _StimuliDimension.xy].z) * _StimuliIntensity;
	}

	return value;
}

float AngleDifference(float angle1, float angle2) {

	float diff = abs(angle1 - angle2);

	while (diff > TWOPI) {
		diff -= TWOPI;
	}

	return diff;
}

/**********************
KERNELS
**********************/

[numthreads(NUM_THREADS,1,1)]
void InitParticles(uint3 id: SV_DISPATCHTHREADID)
{
	InitParticle(id);
}

[numthreads(NUM_THREADS, 1, 1)]
void SpawnParticles(uint3 id: SV_DISPATCHTHREADID)
{

	//Spawn
	if (_ParticleBuffer[id.x].age < 0 && Random(id.x + _AbsoluteTime * 1000) < _EmitterSpawnRate * _DeltaTime / _EmitterCapacity) {
		InitParticle(id);
		_ParticleBuffer[id.x].age = 0;
	}

	//Did not spawn, ignore
	if (_ParticleBuffer[id.x].age < 0)
		return;

	//Age
	_ParticleBuffer[id.x].age += _DeltaTime;

	//Die
	if (_ParticleBuffer[id.x].age > _ParticleBuffer[id.x].lifetime && _ParticleBuffer[id.x].lifetime > 0)
		_ParticleBuffer[id.x].age = -1;
}

[numthreads(NUM_THREADS,1,1)]
void MoveParticles (uint3 id: SV_DISPATCHTHREADID)
{
	if (_ParticleBuffer[id.x].age < 0)
		return;

	float angle = _ParticleBuffer[id.x].angle;
	float2 pos 	= _ParticleBuffer[id.x].position;

	float offset = Random(id.x + 465) * _SensorOffsetDistance;

	float sensorAngle = _SensorAngle;// *_ParticleBuffer[id.x].age / _ParticleBuffer[id.x].lifetime;
	float rotationAngle = _RotationAngle;// *_ParticleBuffer[id.x].age / _ParticleBuffer[id.x].lifetime;

	float2 frontPos 		= pos + float2(cos(angle), sin(angle)) * offset;
	float2 frontLeftPos 	= pos + float2(cos(angle + sensorAngle), sin(angle + sensorAngle)) * offset;
	float2 frontRightPos 	= pos + float2(cos(angle - sensorAngle), sin(angle - sensorAngle)) * offset;
	
	float F 	= ReadTrail(frontPos) + (PI - AngleDifference(angle, _DirectionAngle)) * _DirectionStrength;
	float FL 	= ReadTrail(frontLeftPos) + (PI - AngleDifference(angle + sensorAngle, _DirectionAngle)) * _DirectionStrength;
	float FR 	= ReadTrail(frontRightPos) + (PI - AngleDifference(angle - sensorAngle, _DirectionAngle)) * _DirectionStrength;

	//decide on the next best step
	if((F > FL) && (F > FR))
	{
		//angle -=  rotationAngle;
	}
	else if	((F < FL) && (F < FR))
	{	
		angle = angle + rotationAngle * randomSign(id.x + 369);

		//if (FL > FR) {
		//	angle += rotationAngle;
		//}
		//else {
		//	angle -= rotationAngle;
		//}
	}
	else if	(FL < FR)
	{
		angle -= rotationAngle;
	}
	else if	(FR < FL )
	{
		angle += rotationAngle;
	}

	float2 nextPos = pos + float2(cos(angle), sin(angle)) * _StepSize;

	//check if nextPos is within the boundries
	//float t1 = insideCircle(nextPos, float2(0.5, 0.5), 0.5);
	//angle = angle + _RotationAngle * randomSign(id.x+7129) * (t1-1);
	//nextPos = saturate(nextPos*t1 + pos*(1-t1));

	_ParticleBuffer[id.x].position = nextPos;
	
	//if the particle moved, leave a mark in the trail buffer
	if(distance(nextPos, pos) > 0.0001)
	{
		_TrailBuffer[GetUVFromPosition(nextPos) * _TrailDimension.xy] += _ParticleBuffer[id.x].color;// *_ParticleBuffer[id.x].age / _ParticleBuffer[id.x].lifetime;
	}
	
	_ParticleBuffer[id.x].angle = angle;

	if (_StimuliToColor) {
		_ParticleBuffer[id.x].stimuliIntensity = saturate(_ParticleBuffer[id.x].stimuliIntensity + (ReadStimuli(nextPos) - 0.5) * _DeltaTime * _StimuliIntensity * 0.1);
		_ParticleBuffer[id.x].color = lerp(_EmitterSecondaryColor, _EmitterMainColor, _ParticleBuffer[id.x].stimuliIntensity);
	}
}

[numthreads(NUM_THREADS, NUM_THREADS,1)]
void UpdateTrail (uint3 id : SV_DISPATCHTHREADID)
{

	uint2 sampleId = id.xy +_Gravity;
	float4 value = _TrailBuffer[sampleId];
	
	float3 d = float3(1, -1, 0.0);

	//mean filter
	value = value;
	value += _TrailBuffer[sampleId - d.xx]; // -1,-1
	value += _TrailBuffer[sampleId - d.zx]; // 0, -1
	value += _TrailBuffer[sampleId - d.yx]; // +1, -1
	value += _TrailBuffer[sampleId - d.xz]; // -1, 0
	value += _TrailBuffer[sampleId + d.xz]; // +1, 0
	value += _TrailBuffer[sampleId + d.yx]; // -1, +1
	value += _TrailBuffer[sampleId + d.zx]; // 0, +1
	value += _TrailBuffer[sampleId + d.xx]; // +1, +1
	
	value = (value / 9) * (1-_Decay);

	_TrailBuffer[id.xy] = value;
}

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void CleanParticleTexture(uint3 id : SV_DISPATCHTHREADID)
{
	_ParticleTexture[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(NUM_THREADS, 1, 1)]
void WriteParticleTexture(uint3 id : SV_DISPATCHTHREADID)
{
	if(_ParticleBuffer[id.x].age >= 0)
		_ParticleTexture[GetUVFromPosition(_ParticleBuffer[id.x].position) * _TrailDimension.xy] = float4(1, 1, 1, 1) * (1.0f - _ParticleBuffer[id.x].age / _ParticleBuffer[id.x].lifetime);
}

[numthreads(NUM_THREADS, 1, 1)]
void UpdateParticleMap(uint3 id : SV_DISPATCHTHREADID)
{
	uint2 mapCoord = uint2(id.x % _ParticlePositionMapSize.x, id.x / _ParticlePositionMapSize.x);

	float2 particlePos = _ParticleBuffer[id.x].position;

	_ParticlePositionMap[mapCoord] = float4(particlePos.x, particlePos.y, _ParticleBuffer[id.x].age, _ParticleBuffer[id.x].lifetime);
	//_ParticleColorMap[mapCoord] = _ParticleBuffer[id.x].color;
	//_ParticleVelocityMap[mapCoord] = float4(_ParticleBuffer[id.x].velocity, 1);
}

